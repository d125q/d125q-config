#!/usr/bin/env zsh

## * Usage, option parsing, and global variables

read -r -d '' usage <<EOF
Usage: $( basename $0 ) [OPTION]... PATTERN...
Install packages whose names match PATTERN from their local repositories.
Options:
    -noupdate      do not update from the remote repositories
    -nobuild       do not build the packages
    -nostow        do not stow the packages or their configuration files
    -pkgdir DIR    directory where packages will be installed
                       (default: \$HOME/.local/stow)
    -cfgdir DIR    directory where configuration files will be installed
                       (default: \$HOME/stow)
    -srcdir DIR    directory containing the local repositories
                       (default: \$HOME/.local/src)
    -altdir DIR    directory containing the alternatives
                       (default: \$HOME/Alternatives)
    -admindir DIR  directory containing the administrative information
                       (default: \$HOME/.var/lib/dpkg)
EOF
set -euo pipefail
typeset -a pkgnames=(
    Iosevka
    R
    alacritty
    check
    cppcheck
    ctags
    emacs
    fontforge
    fontship
    git
    grml-etc-core
    libertinus
    libgit2
    ncurses
    noto-fonts
    otfcc
    premake5
    pyenv
    rbenv
    rofi
    tmux
    vim
    zsh
    zsh-completions
    zsh-syntax-highlighting
)
typeset -A opts
zparseopts -D -E -F -A opts -M -                        \
           h help=h                                     \
           noupdate nobuild nostow                      \
           pkgdir: cfgdir: srcdir: altdir: admindir:

if [[ -v opts[-h] ]] ; then
    echo $usage
    exit 0
fi

pkgdir=${opts[-pkgdir]:-$HOME/.local/stow}
cfgdir=${opts[-cfgdir]:-$HOME/stow}
srcdir=${opts[-srcdir]:-$HOME/.local/src}
altdir=${opts[-altdir]:-$HOME/Alternatives}
admindir=${opts[-admindir]:-$HOME/.var/lib/dpkg}

for dir in $pkgdir $cfgdir $srcdir $altdir $admindir ; do
    mkdir -p $dir
done

prefix=$pkgdir/..
bindir=$prefix/bin
datadir=$prefix/share
mandir=$datadir/man
man1dir=$mandir/man1
infodir=$datadir/info
applicationsdir=$datadir/applications
iconsdir=$datadir/icons/hicolor

## * Functions to update, build, install, and stow packages

## ** Iosevka

function clone-Iosevka {
    git clone -b master --depth 1 'git@github.com:be5invis/Iosevka.git'
}

function update-Iosevka {
    git pull --ff-only
}

function build-Iosevka {
    if [[ ! -f private-build-plans.toml ]] ; then
        cat <<'EOF' > private-build-plans.toml
[buildPlans.iosevka-custom]
family      = "Iosevka Custom" # Font menu family name
spacing     = "fixed"          # Optional; Values: `normal`, `term`, `fontconfig-mono`, or `fixed`
serifs      = "slab"           # Optional; Values: `sans` or `slab`
digit-form  = "lining"         # Optional; Values `lining` or `old-style`
no-ligation = true

[buildPlans.iosevka-custom.weights.light]
shape = 300
menu  = 300
css   = 300

[buildPlans.iosevka-custom.weights.regular]
shape = 500
menu  = 400
css   = 400

[buildPlans.iosevka-custom.weights.bold]
shape = 700
menu  = 700
css   = 700

[buildPlans.iosevka-custom.widths.condensed]
shape = 434
menu  = 3
css   = "condensed"

[buildPlans.iosevka-custom.widths.normal]
shape = 500
menu  = 5
css   = "normal"

[buildPlans.iosevka-custom.widths.extended]
shape = 576
menu  = 7
css   = "extended"
EOF
    fi
    npm install
    npm run build -- ttf::iosevka-custom
}

function install-Iosevka {
    local -r tgtdir=$pkgprefix/share/fonts/Iosevka
    mkdir -p $( dirname $tgtdir )
    rsync -avu ./dist/iosevka-custom/ttf/*.ttf $tgtdir
}

function stow-Iosevka {
    stow -d $pkgdir -R $pkgname
}

## ** R

function clone-R {
    svn checkout 'https://svn.r-project.org/R/tags/R-4-0-3/' R
}

function update-R {
    svn update
    ./tools/rsync-recommended
}

function build-R {
    ./configure --prefix=$pkgprefix
    make
    make info
    make pdf
}

function install-R {
    make install
    make install-info
    make install-pdf
    rm $pkginfodir/dir
}

function stow-R {
    stow -d $pkgdir -R $pkgname
    for pkginfofile in $pkginfodir/*.info*.gz ; do
        install-info --info-dir=$infodir $pkginfofile
    done
}

## ** alacritty

function clone-alacritty {
    git clone -b master --depth 1 'git@github.com:alacritty/alacritty.git'
}

function update-alacritty {
    git pull --ff-only
}

function build-alacritty {
    cargo build --release
}

function install-alacritty {
    gzip -c extra/alacritty.man >| extra/alacritty.1.gz
    install -m 755 -D target/release/alacritty \
            -t $pkgbindir
    install -m 644 -D extra/alacritty.1.gz \
            -t $pkgman1dir
    install -m 644 -D extra/logo/alacritty-term.svg \
            $pkgiconsdir/64x64/apps/Alacritty.svg
    install -m 644 -D extra/completions/_alacritty \
            -t $cfgzdotdir/zsh-functions
    desktop-file-install extra/linux/Alacritty.desktop \
                         --dir=$pkgapplicationsdir
}

function stow-alacritty {
    local altname=x-terminal-emulator
    local altlink=$pkgbindir/$altname altslavename=$altname.1.gz
    local altslavelink=$pkgman1dir/$altslavename
    update-alternatives                                                \
        --altdir $altdir --admindir $admindir                          \
        --install $altlink $altname $pkgbindir/alacritty 50            \
        --slave $altslavelink $altslavename $pkgman1dir/alacritty.1.gz
    stow -d $pkgdir -R $pkgname
    stow -d $cfgdir -R $pkgname
    tic -xe alacritty,alacritty-direct extra/alacritty.info
    update-desktop-database $applicationsdir
}

## ** check

function clone-check {
    git clone -b master --depth 1 'git@github.com:libcheck/check.git'
}

function update-check {
    git pull --ff-only
}

function build-check {
    if [[ ! -x ./configure ]] ; then
        autoreconf --install
    fi
    ./configure --prefix=$pkgprefix
    make
}

function install-check {
    make install
    rm $pkginfodir/dir
}

function stow-check {
    stow -d $pkgdir -R $pkgname
    for pkginfofile in $pkginfodir/*.info ; do
        install-info --info-dir=$infodir $pkginfofile
    done
}

## ** cppcheck

function clone-cppcheck {
    git clone -b main --depth 1 'git@github.com:danmar/cppcheck.git'
}

function update-cppcheck {
    git pull --ff-only
}

function build-cppcheck {
    mkdir -p build
    cd build
    cmake -DCMAKE_INSTALL_PREFIX=$pkgprefix -DHAVE_RULES=ON -DUSE_MATCHCOMPILER=ON ..
    cmake --build .
    cd -
}

function install-cppcheck {
    cd build
    cmake --build . --target install
    cd -
    cd htmlreport
    python setup.py install
    cd -
}

function stow-cppcheck {
    stow -d $pkgdir -R $pkgname
}

## ** ctags

function clone-ctags {
    git clone -b master --depth 1 'git@github.com:universal-ctags/ctags.git'
}

function update-ctags {
    git pull --ff-only
}

function build-ctags {
    if [[ ! -x ./configure ]] ; then
        ./autogen.sh
    fi
    ./configure --prefix=$pkgprefix
    make
}

function install-ctags {
    make install
}

function stow-ctags {
    stow -d $pkgdir -R $pkgname
}

## ** emacs

function clone-emacs {
    git clone -b master --depth 1 'git://git.sv.gnu.org/emacs.git'
}

function update-emacs {
    git pull --ff-only
}

function build-emacs {
    if [[ ! -x ./configure ]] ; then
        ./autogen.sh autoconf
    fi
    ./configure --prefix=$pkgprefix    \
                --with-x               \
                --with-x-toolkit=lucid \
                --with-cairo           \
                --with-json            \
                --with-imagemagick
    make bootstrap
    make docs
}

function install-emacs {
    make systemdunitdir=$HOME/.config/systemd/user install
    rm $pkginfodir/dir
    mv $pkgbindir/ctags $pkgbindir/ctags.emacs
    mv $pkgman1dir/ctags.1.gz $pkgman1dir/ctags.emacs.1.gz
}

function stow-emacs {
    stow -d $pkgdir -R $pkgname
    for pkginfofile in $pkginfodir/*.info*.gz ; do
        install-info --info-dir=$infodir $pkginfofile
    done
    if read -q '?Restart the GNU Emacs daemon? ' ; then
        echo
        systemctl --user daemon-reload
        systemctl --user restart emacs.service
    else
        echo
    fi
}

## ** fontforge

function clone-fontforge {
    git clone -b master --depth 1 'git@github.com:fontforge/fontforge.git'
}

function update-fontforge {
    git pull --ff-only
}

function build-fontforge {
    mkdir -p build
    cd build
    local -TU PYENV_PREFIX pyenv_prefix
    PYENV_PREFIX=$( pyenv prefix )
    cmake -GNinja                                       \
          -DCMAKE_PREFIX_PATH=${(j:;:)pyenv_prefix}     \
          -DCMAKE_INSTALL_PREFIX=$pkgprefix             \
          ..
    ninja
    cd -
}

function install-fontforge {
    cd build
    ninja install
    cd -
}

function stow-fontforge {
    stow -d $pkgdir -R $pkgname
}

## ** fontship

function clone-fontship {
    git clone -b master --depth 1 'git@github.com:theleagueof/fontship.git'
}

function update-fontship {
    git pull --ff-only
}

function build-fontship {
    source ${WORKON_HOME:-$HOME/.virtualenvs}/fontship/bin/activate
    pip install -U -r requirements.txt
    if [[ ! -x ./configure ]] ; then
        ./bootstrap.sh
    fi
    ./configure --prefix=$pkgprefix
    make
    deactivate
}

function install-fontship {
    local bashcompletiondir=$pkgprefix/share/bash-completions
    make bashcompletiondir=$bashcompletiondir install
}

function stow-fontship {
    stow -d $pkgdir -R $pkgname
}

## ** git

function clone-git {
    git clone -b master --depth 1 'git@github.com:git/git.git'
}

function update-git {
    git pull --ff-only
}

function build-git {
    if [[ ! -x ./configure ]] ; then
        make configure
    fi
    ./configure --prefix=$pkgprefix
    make all doc
}

function install-git {
    make install install-doc install-html
}

function stow-git {
    stow -d $pkgdir -R $pkgname
}

## ** grml-etc-core

function clone-grml-etc-core {
    git clone -b master --depth 1 'git://git.grml.org/grml-etc-core.git'
}

function update-grml-etc-core {
    git pull --ff-only
}

function build-grml-etc-core {
    echo "Nothing to build."
}

function install-grml-etc-core {
    mkdir -p $cfgprefix
    install -m 644 -D etc/vim/vimrc $cfgprefix/.vimrc
    install -m 644 -D etc/zsh/zshrc $cfgprefix/.config/zsh/.zshrc
}

function stow-grml-etc-core {
    stow -d $cfgdir -R $pkgname
}

## ** libertinus

function clone-libertinus {
    git clone -b master --depth 1 'git@github.com:alerque/libertinus.git'
}

function update-libertinus {
    git pull --ff-only
}

function build-libertinus {
    source ${WORKON_HOME:-$HOME/.virtualenvs}/fontship/bin/activate
    fontship make otf
    deactivate
}

function install-libertinus {
    local -r tgtdir=$pkgprefix/share/fonts/Libertinus
    mkdir -p $( dirname $tgtdir )
    rsync -avu ./*.otf $tgtdir
}

function stow-libertinus {
    stow -d $pkgdir -R $pkgname
}

## ** libgit2

function clone-libgit2 {
    git clone -b main --depth 1 'git@github.com:libgit2/libgit2.git'
}

function update-libgit2 {
    git pull --ff-only
}

function build-libgit2 {
    mkdir -p build
    cd build
    cmake -DCMAKE_INSTALL_PREFIX=$pkgprefix ..
    cmake --build .
    cd -
}

function install-libgit2 {
    cd build
    cmake --build . --target install
    cd -
}

function stow-libgit2 {
    stow -d $pkgdir -R $pkgname
}

## ** ncurses

function clone-ncurses {
    git clone -b master --depth 1 'git@github.com:mirror/ncurses.git'
}

function update-ncurses {
    git pull --ff-only
}

function build-ncurses {
    ./configure --prefix=$pkgprefix
    make
}

function install-ncurses {
    make install
}

function stow-ncurses {
    stow -d $pkgdir -R $pkgname
}

## ** noto-fonts

function clone-noto-fonts {
    git clone -b master --depth 1 'git@github.com:googlefonts/noto-fonts.git'
}

function update-noto-fonts {
    git pull --ff-only
}

function build-noto-fonts {
    echo "Nothing to build."
}

function install-noto-fonts {
    local -r tgtdir=$pkgprefix/share/fonts/Noto
    mkdir -p $( dirname $tgtdir )
    rsync -avu ./unhinted/otf/ $tgtdir
}

function stow-noto-fonts {
    stow -d $pkgdir -R $pkgname
}

## ** otfcc

function clone-otfcc {
    git clone -b master --depth 1 'git@github.com:caryll/otfcc.git'
}

function update-otfcc {
    git pull --ff-only
}

function build-otfcc {
    premake5 ninja
    cd build/ninja
    ninja otfccbuild_release_x64 otfccdump_release_x64
    cd -
}

function install-otfcc {
    install -m 755 -D -t $pkgbindir bin/release-x64/otfcc{build,dump}
}

function stow-otfcc {
    stow -d $pkgdir -R $pkgname
}

## ** premake5

function clone-premake5 {
    git clone -b master --depth 1 'git@github.com:premake/premake-core.git' premake5
}

function update-premake5 {
    git pull --ff-only
}

function build-premake5 {
    if [[ -v commands[premake5] ]] ; then
        premake5 gmake
        make
    else
        make -f Bootstrap.mak linux
    fi
}

function install-premake5 {
    install -m 755 -D -t $pkgbindir bin/release/premake5
}

function stow-premake5 {
    stow -d $pkgdir -R $pkgname
}

## ** pyenv

function clone-pyenv {
    git clone -b master --depth 1 'git@github.com:pyenv/pyenv.git'
}

function update-pyenv {
    git pull --ff-only
}

function build-pyenv {
    echo "Nothing to build."
}

function install-pyenv {
    mkdir -p $cfgprefix/.pyenv
    rsync -avu --exclude .git/ ./ $cfgprefix/.pyenv
}

function stow-pyenv {
    stow -d $cfgdir -R $pkgname
}

## ** rbenv

function clone-rbenv {
    git clone -b master --depth 1 'git@github.com:rbenv/rbenv.git'
    mkdir -p rbenv/plugins
    cd rbenv/plugins
    git clone -b master --depth 1 'git@github.com:rbenv/ruby-build.git'
    cd -
}

function update-rbenv {
    git pull --ff-only
    cd plugins/ruby-build
    git pull --ff-only
    cd -
}

function build-rbenv {
    echo "Nothing to build."
}

function install-rbenv {
    mkdir -p $cfgprefix/.rbenv
    rsync -avu --exclude .git ./ $cfgprefix/.rbenv
}

function stow-rbenv {
    stow -d $cfgdir -R $pkgname
}

## ** rofi

function clone-rofi {
    git clone --recursive 'git@github.com:davatorium/rofi.git'
}

function update-rofi {
    git pull --ff-only
    git submodule update --remote
}

function build-rofi {
    mkdir -p build
    meson setup build --prefix $pkgprefix
    ninja -C build
}

function install-rofi {
    ninja -C build install
}

function stow-rofi {
    stow -d $pkgdir -R $pkgname
}

## ** tmux

function clone-tmux {
    git clone -b master --depth 1 'git@github.com:tmux/tmux.git'
}

function update-tmux {
    git pull --ff-only
}

function build-tmux {
    if [[ ! -x ./configure ]] ; then
        ./autogen.sh
    fi
    ./configure --prefix=$pkgprefix
    make
}

function install-tmux {
    make install
}

function stow-tmux {
    stow -d $pkgdir -R $pkgname
}

## ** vim

function clone-vim {
    git clone -b master --depth 1 'git@github.com:vim/vim.git'
}

function update-vim {
    git pull --ff-only
}

function build-vim {
    ./configure --prefix=$pkgprefix        \
                --with-features=huge       \
                --enable-multibyte         \
                --enable-luainterp=yes     \
                --enable-perlinterp=yes    \
                --enable-python3interp=yes \
                --enable-rubyinterp=yes    \
                --enable-tclinterp=yes     \
                --enable-gui=gtk3          \
                --enable-cscope
    make
}

function install-vim {
    make install
}

function stow-vim {
    local altname altlink altslavename altslavelink
    for altname in editor vi ; do
        altlink=$pkgbindir/$altname
        altslavename=$altname.1
        altslavelink=$pkgman1dir/$altslavename
        update-alternatives                                       \
            --altdir $altdir --admindir $admindir                 \
            --install $altlink $altname $pkgbindir/vim 50         \
            --slave $altslavelink $altslavename $pkgman1dir/vim.1
    done
    stow -d $pkgdir -R $pkgname
}

## ** zsh

function clone-zsh {
    git clone -b master --depth 1 'git://git.code.sf.net/p/zsh/code'
}

function update-zsh {
    git pull --ff-only
}

function build-zsh {
    if [[ ! -x ./configure ]] ; then
        ./Util/preconfig
    fi
    ./configure --prefix=$pkgprefix
    make
}

function install-zsh {
    make install
    make install.info
    rm $infodir/dir
}

function stow-zsh {
    stow -d $pkgdir -R $pkgname
    for pkginfofile in $infodir/zsh.info* ; do
        install-info --info-dir=$infodir $pkginfofile
    done
}

## ** zsh-completions

function clone-zsh-completions {
    git clone -b master --depth 1 'git@github.com:zsh-users/zsh-completions.git'
}

function update-zsh-completions {
    git pull --ff-only
}

function build-zsh-completions {
    echo "Nothing to build."
}

function install-zsh-completions {
    mkdir -p $cfgzdotdir/$pkgname
    rsync -avu ./src/ $cfgzdotdir/$pkgname
}

function stow-zsh-completions {
    stow -d $cfgdir -R $pkgname
}

## ** zsh-syntax-highlighting

function clone-zsh-syntax-highlighting {
    git clone -b master --depth 1 'git@github.com:zsh-users/zsh-syntax-highlighting.git'
}

function update-zsh-syntax-highlighting {
    git pull --ff-only
}

function build-zsh-syntax-highlighting {
    echo "Nothing to build."
}

function install-zsh-syntax-highlighting {
    mkdir -p $cfgzdotdir/$pkgname
    rsync -avu --exclude .git/ ./ $cfgzdotdir/$pkgname
}

function stow-zsh-syntax-highlighting {
    stow -d $cfgdir -R $pkgname
}

## * Main program

function process-pkg {
    local -r pkgname=$1
    local -r pkgprefix=$pkgdir/$pkgname
    local -r pkgbindir=$pkgprefix/bin    \
             pkgdatadir=$pkgprefix/share
    local -r pkgmandir=$pkgdatadir/man                   \
             pkginfodir=$pkgdatadir/info                 \
             pkgapplicationsdir=$pkgdatadir/applications \
             pkgiconsdir=$pkgdatadir/icons/hicolor
    local -r pkgman1dir=$pkgmandir/man1

    local -r cfgprefix=$cfgdir/$pkgname
    local -r cfgzdotdir=$cfgprefix/.config/zsh

    local -i skipupdate=0

    cd $srcdir
    if [[ ! -d $pkgname ]] ; then
        echo "Cloning $pkgname..."
        clone-$pkgname
        skipupdate=1
    fi
    cd $pkgname
    if ! (( skipupdate )) && [[ ! -v opts[-noupdate] ]] ; then
        echo "Updating $pkgname..."
        update-$pkgname
    fi
    if [[ ! -v opts[-nobuild] ]] ; then
        echo "Building $pkgname..."
        build-$pkgname
    fi
    echo "Installing $pkgname..."
    install-$pkgname
    if [[ ! -v opts[-nostow] ]] ; then
        echo "Stowing $pkgname..."
        stow-$pkgname
    fi
}

for pattern in $@ ; do
    for pkgname in ${(M)pkgnames:#${~pattern}} ; do
        process-pkg $pkgname
    done
done
